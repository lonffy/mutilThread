package mutilthread.thread.volatitletest;import java.util.Random;/** * volatile 关键字 * 作用二: 线程可见性 *关键原理:每个线程都有自己的本地内存, 修改公共变量时(比如静态变量)会先将变量拷贝到本地内存,操作完再写回主存 * 案例: A和B两个线程同时启动,B线程修改轮流修改count=1或者count=2, A线程监控公共变量count, 一旦发现count=1或者count=2就输出count的值 * 场景一: 不用volatile关键字修饰count ===>见案例1 * 无论A怎么修改count的值, B拿到的count一直是0,不会拿到A修改的count值,即使A线程执行结束,B都拿不到A修改的count值; * 因为线程B一直拿到的是本地内存的B * 场景二: 线程B中途sleep一会, 就能拿到线程A修改的count值, 即使这时候线程A还没结束  ==>见例子2 * 说明线程B从就绪状态到运行状态时会重新从主存中取count变量 * 场景三: 用volatile关键字修饰count * B随时可以拿到A线程修改的count值 ==>见例子3 * */public class T_01 {    private volatile static int count = 0;    public static void main(String[] args) {        Thread t2 = new Thread(new Runnable() {            @Override            public void run() {                for (int i = 0; i < 11; i++) {                    try {// 这里是为了测试看效果                        Thread.sleep(new Random().nextInt(1000));                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    //轮流设置count为1或者2                    if(i%2==0){                        count = 2;                        System.out.println(Thread.currentThread().getName()+" 已经设置为2");                    }else{                        count = 1;                        System.out.println(Thread.currentThread().getName()+" 已经设置为1");                    }                }            }        });        new Thread(new Runnable() {            @Override            public void run() {                //一直监听看看能否拿到count=1或者count=2                while(true){                    try {                        Thread.sleep(100);                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                    if(count==1){                        System.out.println(Thread.currentThread().getName()+" 拿到1");                    }else if (count==2){                        System.out.println(Thread.currentThread().getName()+" 拿到2");                    }                }            }        }).start();        t2.start();        }    }